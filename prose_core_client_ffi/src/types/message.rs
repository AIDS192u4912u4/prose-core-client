use std::{
    fmt::{self, Display, Formatter},
    str::FromStr,
};

use jid::BareJid;
use libstrophe::Stanza;

#[derive(Debug, PartialEq)]
pub enum MessageKind {
    /// The message is sent in the context of a one-to-one chat conversation.
    Chat,
    /// An error has occurred related to a previous message sent by the sender.
    Error,
    /// The message is sent in the context of a multi-user chat environment.
    Groupchat,
    /// The message is probably generated by an automated service that delivers or
    /// broadcasts content.
    Headline,
    /// The message is a single message that is sent outside the context of a
    /// one-to-one conversation or groupchat, and to which it is expected that the
    /// recipient will reply.
    Normal,
}

#[derive(Debug, PartialEq)]
pub struct Message {
    pub from: BareJid,
    /// An instant messaging client SHOULD specify an intended recipient for a message by
    /// providing the JID of an entity other than the sender in the 'to' attribute of the
    /// <message/> stanza. If the message is being sent in reply to a message previously
    /// received from an address of the form <user@domain/resource> (e.g., within the
    /// context of a chat session), the value of the 'to' address SHOULD be of the form
    /// <user@domain/resource> rather than of the form <user@domain> unless the sender
    /// has knowledge (via presence) that the intended recipient's resource is no longer
    /// available. If the message is being sent outside the context of any existing chat
    /// session or received message, the value of the 'to' address SHOULD be of the form
    /// <user@domain> rather than of the form <user@domain/resource>.
    pub to: Option<BareJid>,

    pub id: Option<String>,

    /// The 'type' attribute of a message stanza is RECOMMENDED; if included, it specifies
    /// the conversational context of the message, thus providing a hint regarding
    /// presentation (e.g., in a GUI).
    pub kind: Option<MessageKind>,

    /// The <body/> element contains human-readable XML character data that specifies the
    /// textual contents of the message; this child element is normally included but is
    /// OPTIONAL. The <body/> element MUST NOT possess any attributes, with the exception
    /// of the 'xml:lang' attribute. Multiple instances of the <body/> element MAY be
    /// included but only if each instance possesses an 'xml:lang' attribute with a
    /// distinct language value. The <body/> element MUST NOT contain mixed content.
    pub body: Option<String>,

    /// If the message stanza is of type "error", it MUST include an <error/> child.
    pub error: Option<String>,
}

impl TryFrom<&Stanza> for Message {
    fn try_from(stanza: &Stanza) -> Result<Self, Self::Error> {
        Ok(Message {
            from: stanza
                .from()
                .map(BareJid::from_str)
                .ok_or(())?
                .map_err(|_| ())?,
            to: stanza
                .get_attribute("to")
                .and_then(|s| BareJid::from_str(s).ok()),
            id: stanza.get_attribute("id").map(|s| s.to_string()),
            kind: stanza
                .get_attribute("type")
                .map(|s| s.to_string())
                .or_else(|| stanza.get_child_by_name("type").and_then(|n| n.text()))
                .and_then(|s| s.parse::<MessageKind>().ok()),
            body: stanza.get_child_by_name("body").and_then(|n| n.text()),
            error: stanza.get_child_by_name("error").and_then(|n| n.text()),
        })
    }

    type Error = ();
}

impl FromStr for MessageKind {
    type Err = ();

    fn from_str(input: &str) -> Result<MessageKind, Self::Err> {
        match input {
            "chat" => Ok(MessageKind::Chat),
            "error" => Ok(MessageKind::Error),
            "groupchat" => Ok(MessageKind::Groupchat),
            "headline" => Ok(MessageKind::Headline),
            "normal" => Ok(MessageKind::Normal),
            _ => Err(()),
        }
    }
}

impl Display for MessageKind {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            MessageKind::Chat => write!(f, "chat"),
            MessageKind::Error => write!(f, "error"),
            MessageKind::Groupchat => write!(f, "groupchat"),
            MessageKind::Headline => write!(f, "headline"),
            MessageKind::Normal => write!(f, "normal"),
        }
    }
}

#[cfg(test)]
mod tests {
    use libstrophe::Stanza;

    use super::*;

    #[test]
    fn test_deserialize_empty_message() {
        let presence = r#"
        <message from="valerian@prose.org"/>
        "#;

        let stanza = Stanza::from_str(presence);
        let message = Message::try_from(&stanza).unwrap();

        assert_eq!(
            message,
            Message {
                from: BareJid::from_str("valerian@prose.org").unwrap(),
                to: None,
                id: None,
                kind: None,
                body: None,
                error: None,
            }
        );
    }

    #[test]
    fn test_deserialize_full_message() {
        let presence = r#"
      <message from="valerian@prose.org/mobile" to="marc@prose.org/home" id="purplecf8f33c0" type="chat">
        <body>How is it going?</body>
      </message>
      "#;

        let stanza = Stanza::from_str(presence);
        let message = Message::try_from(&stanza).unwrap();

        assert_eq!(
            message,
            Message {
                from: BareJid::from_str("valerian@prose.org").unwrap(),
                to: Some(BareJid::from_str("marc@prose.org").unwrap()),
                id: Some("purplecf8f33c0".to_string()),
                kind: Some(MessageKind::Chat),
                body: Some("How is it going?".to_string()),
                error: None,
            }
        );
    }

    #[test]
    fn test_deserialize_error_message() {
        let presence = r#"
    <message from="valerian@prose.org/mobile" type="error">
      <error>Something went wrong</error>
    </message>
    "#;

        let stanza = Stanza::from_str(presence);
        let message = Message::try_from(&stanza).unwrap();

        assert_eq!(
            message,
            Message {
                from: BareJid::from_str("valerian@prose.org").unwrap(),
                to: None,
                id: None,
                kind: Some(MessageKind::Error),
                body: None,
                error: Some("Something went wrong".to_string()),
            }
        );
    }
}
