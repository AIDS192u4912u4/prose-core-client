namespace ProseCoreClientFFI {
  void enable_logging();

  [Throws=ProseError]
  BareJid parse_jid([ByRef] string jid);

  string format_jid([ByRef] BareJid jid);
};

[Custom]
typedef string MessageId;

interface XMPPClient {
  constructor(FullJid jid);

  FullJid jid();

  [Throws=ProseError]
  void connect([ByRef] string password, XMPPAccountObserver observer);

  [Throws=ProseError]
  void send_message(MessageId id, [ByRef] BareJid to, [ByRef] string body, XMPPChatState? chat_state);

  [Throws=ProseError]
  void update_message(MessageId id, MessageId new_id, [ByRef] BareJid to, [ByRef] string body);

  [Throws=ProseError]
  void send_chat_state([ByRef] BareJid to, XMPPChatState chat_state);

  [Throws=ProseError]
  void send_presence(XMPPShowKind? show, [ByRef] string? status);

  [Throws=ProseError]
  void load_roster();

  [Throws=ProseError]
  void add_user_to_roster([ByRef] BareJid jid, [ByRef] string? nickname, [ByRef] sequence<string> groups);

  [Throws=ProseError]
  void remove_user_and_unsubscribe_from_presence([ByRef] BareJid jid);

  [Throws=ProseError]
  void subscribe_to_user_presence([ByRef] BareJid jid);

  [Throws=ProseError]
  void unsubscribe_from_user_presence([ByRef] BareJid jid);

  [Throws=ProseError]
  void grant_presence_permission_to_user([ByRef] BareJid jid);

  [Throws=ProseError]
  void revoke_or_reject_presence_permission_from_user([ByRef] BareJid jid);

  [Throws=ProseError]
  void load_archiving_preferences();

  [Throws=ProseError]
  void set_archiving_preferences([ByRef] XMPPMAMPreferences preferences);

  [Throws=ProseError]
  void load_messages_in_chat([ByRef] string request_id, [ByRef] BareJid jid, MessageId? before);

  [Throws=ProseError]
  void send_reactions(MessageId id, [ByRef] BareJid to, [ByRef] sequence<string> reactions);

  [Throws=ProseError]
  void retract_message(MessageId id, [ByRef] BareJid to);

  [Throws=ProseError]
  void set_avatar_image([ByRef] string request_id, XMPPImage image);

  [Throws=ProseError]
  void load_latest_avatar_metadata([ByRef] string request_id, [ByRef] BareJid from);

  [Throws=ProseError]
  void load_avatar_image([ByRef] string request_id, [ByRef] BareJid from, [ByRef] string image_id);

  [Throws=ProseError]
  void send_xml_payload([ByRef] string xml_string);
};

callback interface XMPPAccountObserver {
  void did_connect();
  void did_disconnect();
  
  void did_receive_message(XMPPMessage message);
  void did_receive_message_carbon(XMPPForwardedMessage message);
  void did_receive_sent_message_carbon(XMPPForwardedMessage message);
  void did_receive_roster(XMPPRoster roster);
  void did_receive_presence(XMPPPresence presence);
  void did_receive_presence_subscription_request(BareJid from);
  void did_receive_archiving_preferences(XMPPMAMPreferences preferences);
  void did_receive_messages_in_chat(
    string requestId,
    BareJid jid,
    sequence<XMPPForwardedMessage> messages,
    boolean isComplete
  );
  void did_load_avatar_image(string requestId, BareJid jid, XMPPAvatarData? image);
  void did_load_avatar_metadata(string requestId, BareJid jid, sequence<XMPPAvatarMetadataInfo> metadata);
  void did_set_avatar_image(string requestId, string imageId);
  void did_receive_updated_avatar_metadata(BareJid jid, sequence<XMPPAvatarMetadataInfo> metadata);
};

[Error]
enum JidParseError {
  "NoDomain",
  "NoResource",
  "EmptyNode",
  "EmptyResource",
};

[Error]
enum LibStropheError {
  "MemoryError",
  "InvalidOperation",
  "InternalError",
};

[Error]
interface StanzaParseError {
  MissingAttribute(string attribute);
  MissingChildNode(string node);
  MissingText(string node);
  ParseError(string error);
  JidParseError(JidParseError error);
  DecodeError(string error);
};

[Error]
interface ProseError {
  JidParseError(JidParseError error);
  StropheError(LibStropheError error);
  ConnectClientError(LibStropheError error);
  ConnectionError(string error);
  BorrowMutError(string error);
  PoisonError(string error);
  StanzaParseError(StanzaParseError error);
  SendError(string error);
  IOError(string error);
  ToTextError(string error);
  ChronoParseError(string error);
};

enum XMPPMessageKind {
  "Chat", 
  "Error", 
  "Groupchat", 
  "Headline", 
  "Normal",
};

enum XMPPChatState {
  "Active", 
  "Composing", 
  "Gone", 
  "Inactive", 
  "Paused",
};

dictionary XMPPMessageReactions {
  MessageId id;
  sequence<string> reactions;
};

dictionary XMPPMessageFastening {
  MessageId id;
  boolean retract;
};

dictionary XMPPMessage {
  BareJid from;
  BareJid? to;
  MessageId? id;
  XMPPMessageKind? kind;
  string? body;
  XMPPChatState? chat_state;
  MessageId? replace;
  XMPPMessageReactions? reactions;
  XMPPMessageFastening? fastening;
  string? error;
};

dictionary XMPPDelay {
  i64 stamp;
  BareJid? from;
};

dictionary XMPPForwardedMessage {
  XMPPDelay? delay;
  XMPPMessage message;
};

dictionary XMPPImage {
  sequence<u8> data;
  string mime_type;
  u32 width;
  u32 height;
};

dictionary XMPPAvatarData {
  sequence<u8> data;
  string sha1;
};

dictionary XMPPAvatarMetadataInfo {
  string id;
  string? url;
  u32? bytes;
  u32? width;
  u32? height;
  string? mime_type;
};

dictionary BareJid {
  string? node;
  string domain;
};

dictionary FullJid {
  string? node;
  string domain;
  string resource;
};

dictionary XMPPRoster {
  sequence<XMPPRosterGroup> groups;
};

dictionary XMPPRosterGroup {
  string name;
  sequence<XMPPRosterItem> items;
};

enum XMPPRosterItemSubscription {
  "None",
  "To",
  "From",
  "Both",
};

dictionary XMPPRosterItem {
  BareJid jid;
  XMPPRosterItemSubscription subscription;
};

enum XMPPPresenceKind {
  "Unavailable", 
  "Subscribe", 
  "Subscribed", 
  "Unsubscribe", 
  "Unsubscribed", 
  "Probe", 
  "Error",
};

enum XMPPShowKind {
  "Away",
  "Chat", 
  "DND",
  "XA",
};

dictionary XMPPPresence {
  XMPPPresenceKind? kind;
  BareJid? from;
  BareJid? to;
  XMPPShowKind? show;
  string? status;
};

enum XMPPMAMDefaultBehavior {
  "Always",
  "Never",
  "Roster",
};

dictionary XMPPMAMPreferences {
  XMPPMAMDefaultBehavior default_behavior;
  sequence<BareJid> always_archive;
  sequence<BareJid> never_archive;
};