namespace ProseCoreClientFFI {
  void enable_logging();

  [Throws=ProseError]
  BareJid parse_jid([ByRef] string jid);

  string format_jid([ByRef] BareJid jid);
};

interface Client {
  constructor(BareJid jid);

  BareJid jid();

  [Throws=ProseError]
  void connect([ByRef] string password, AccountObserver observer);

  [Throws=ProseError]
  void send_message([ByRef] string id, [ByRef] BareJid to, [ByRef] string body, ChatState? chat_state);

  [Throws=ProseError]
  void update_message([ByRef] string id, [ByRef] string new_id, [ByRef] BareJid to, [ByRef] string body);

  [Throws=ProseError]
  void send_chat_state([ByRef] BareJid to, ChatState chat_state);

  [Throws=ProseError]
  void send_presence(ShowKind? show, [ByRef] string? status);

  [Throws=ProseError]
  void load_roster();

  [Throws=ProseError]
  void send_xml_payload([ByRef] string xml_string);
};

callback interface AccountObserver {
  void did_connect();
  void did_disconnect();
  
  void did_receive_message(Message message);
  void did_receive_roster(Roster roster);
  void did_receive_presence(Presence presence);
};

[Error]
enum JidParseError {
  "NoDomain",
  "NoResource",
  "EmptyNode",
  "EmptyResource",
};

[Error]
enum LibStropheError {
  "MemoryError",
  "InvalidOperation",
  "InternalError",
};

[Error]
interface StanzaParseError {
  MissingAttribute(string attribute);
  MissingChildNode(string node);
  ParseError(string error);
  JidParseError(JidParseError error);
};

[Error]
interface ProseError {
  JidParseError(JidParseError error);
  StropheError(LibStropheError error);
  ConnectClientError(LibStropheError error);
  ConnectionError(string error);
  BorrowMutError(string error);
  PoisonError(string error);
  StanzaParseError(StanzaParseError error);
  SendError(string error);
  IOError(string error);
  ToTextError(string error);
};

enum MessageKind {
  "Chat", 
  "Error", 
  "Groupchat", 
  "Headline", 
  "Normal",
};

enum ChatState {
  "Active", 
  "Composing", 
  "Gone", 
  "Inactive", 
  "Paused",
};

dictionary Message {
  BareJid from;
  BareJid? to;
  string? id;
  MessageKind? kind;
  string? body;
  ChatState? chat_state;
  string? replace;
  string? error;
};

dictionary BareJid {
  string? node;
  string domain;
};

dictionary Roster {
  sequence<RosterGroup> groups;
};

dictionary RosterGroup {
  string name;
  sequence<RosterItem> items;
};

enum RosterItemSubscription {
  "None",
  "To",
  "From",
  "Both",
};

dictionary RosterItem {
  BareJid jid;
  RosterItemSubscription subscription;
};

enum PresenceKind {
  "Unavailable", 
  "Subscribe", 
  "Subscribed", 
  "Unsubscribe", 
  "Unsubscribed", 
  "Probe", 
  "Error",
};

enum ShowKind {
  "Away",
  "Chat", 
  "DND",
  "XA",
};

dictionary Presence {
  PresenceKind? kind;
  BareJid? from;
  BareJid? to;
  ShowKind? show;
  string? status;
};